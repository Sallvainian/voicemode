#!/usr/bin/env bash
# Pretty-print voice-mode exchange logs with full v2 schema support

set -euo pipefail

# Default to today's log file
LOG_DIR="${HOME}/.voicemode/logs"
TODAY=$(date +%Y-%m-%d)
LOG_FILE="${LOG_DIR}/exchanges_${TODAY}.jsonl"

# Parse command line options
SHOW_FULL=false
FILTER_TYPE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--full)
            SHOW_FULL=true
            shift
            ;;
        --stt)
            FILTER_TYPE="stt"
            shift
            ;;
        --tts)
            FILTER_TYPE="tts"
            shift
            ;;
        -h|--help)
            echo "Usage: $(basename "$0") [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  -f, --full    Show full metadata including silence detection"
            echo "  --stt         Show only STT (speech-to-text) entries"
            echo "  --tts         Show only TTS (text-to-speech) entries"
            echo "  -h, --help    Show this help message"
            exit 0
            ;;
        *)
            LOG_FILE="$1"
            shift
            ;;
    esac
done

# Check if log file exists
if [[ ! -f "$LOG_FILE" ]]; then
    echo "No exchanges log found at: $LOG_FILE"
    echo ""
    echo "Available logs:"
    ls -la "$LOG_DIR"/exchanges_*.jsonl 2>/dev/null || echo "  No exchange logs found"
    exit 1
fi

echo "📊 Tailing exchanges log: $LOG_FILE"
echo "   Press Ctrl+C to stop"
echo ""

# Build jq filter based on options
JQ_FILTER='.'
if [[ -n "$FILTER_TYPE" ]]; then
    JQ_FILTER="select(.type == \"$FILTER_TYPE\")"
fi

# Simple format that's more robust
tail -f "$LOG_FILE" | while IFS= read -r line; do
    # Skip empty lines
    [[ -z "$line" ]] && continue
    
    # Parse JSON and format, then strip quotes and add colors
    formatted=$(echo "$line" | jq -C --arg filter "$FILTER_TYPE" --argjson full "$SHOW_FULL" '
        # Apply filter if specified
        if $filter != "" and .type != $filter then empty
        else
            # Extract just the time portion
            (.timestamp | split("T")[1] | split(".")[0]) as $time |
            
            # Format transport info
            (.metadata.transport // "local") as $transport |
            (.metadata.provider // "?") as $provider |
            
            # Build transport display
            (if $transport == "local" then "🎙️" 
             elif $transport == "livekit" then "☁️"
             else $transport end) as $transport_icon |
            
            # Format based on type
            if .type == "stt" then
                "[\($time)] 🎤 STT \($transport_icon) \(.text[0:80])\(if .text | length > 80 then "..." else "" end)" +
                (if .metadata.timing then " [\(.metadata.timing)]" else "" end) +
                (if $full and .metadata.silence_detection then " [VAD: \(.metadata.silence_detection.enabled)]" else "" end)
            else
                "[\($time)] 🔊 TTS \($transport_icon) \(.text[0:80])\(if .text | length > 80 then "..." else "" end)" +
                (if .metadata.voice then " (\(.metadata.voice))" else "" end) +
                (if .metadata.timing then " [\(.metadata.timing)]" else "" end) +
                (if $full and $provider then " [\($provider)]" else "" end)
            end
        end
    ' 2>/dev/null || true)
    
    # Strip quotes but keep colors by removing first and last character
    if [[ -n "$formatted" ]] && [[ "$formatted" != "null" ]]; then
        # Remove surrounding quotes
        formatted="${formatted#\"}"
        formatted="${formatted%\"}"
        
        # Apply color based on type
        if [[ "$line" == *'"type":"stt"'* ]]; then
            echo -e "\033[32m$formatted\033[0m"  # Green for STT
        elif [[ "$line" == *'"type":"tts"'* ]]; then
            echo -e "\033[33m$formatted\033[0m"  # Yellow for TTS
        else
            echo "$formatted"
        fi
    fi
done